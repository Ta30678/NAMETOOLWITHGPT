<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ETABS 梁自動編號工具</title>

    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* --- 淺色主題 --- */
      :root {
        --theme-bg: #f1f5f9;
        --theme-surface: #ffffff;
        --theme-border: #e2e8f0;
        --theme-shadow: rgba(0, 0, 0, 0.05);
        --theme-text-primary: #1e293b;
        --theme-text-secondary: #64748b;
        --theme-accent: #f97316;
        --theme-accent-hover: #ea580c;
        --theme-success: #22c55e;
        --theme-success-hover: #16a34a;
        /* --- ↓↓↓ 將這段程式碼加到這裡 ↓↓↓ --- */
        *,
        *::before,
        *::after {
          box-sizing: border-box;
        }
        /* --- ↑↑↑ 將這段程式碼加到這裡 ↑↑↑ --- */
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      body {
        font-family: "Inter", "Microsoft JhengHei", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        padding: 26px 14px;
        color: var(--theme-text-primary);
        background-color: var(--theme-bg);
        position: relative;
      }

      #container {
        width: 90%;
        max-width: none;
        background: var(--theme-surface);
        padding: 20px;
        border-radius: 18px;
        border: 1px solid var(--theme-border);
        box-shadow: 0 10px 25px -5px var(--theme-shadow),
          0 8px 10px -6px var(--theme-shadow);
        animation: fadeIn 0.8s ease-out forwards;
        position: relative;
        z-index: 1;
      }

      h1 {
        font-size: 2.25rem;
        font-weight: 700;
        color: var(--theme-text-primary);
        text-align: center;
        margin-bottom: 2.5rem;
        position: relative;
      }

      h1::after {
        content: "";
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 80px;
        height: 3px;
        background: var(--theme-accent);
        border-radius: 2px;
      }

      h3 {
        color: var(--theme-text-primary);
        font-weight: 500;
        border-bottom: 1px solid var(--theme-border);
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
        opacity: 0.9;
      }

      .control-area {
        margin-bottom: 25px;
        padding: 20px;
        border-radius: 12px;
        background: var(--theme-bg);
        border: 1px solid var(--theme-border);
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      .control-group {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      label {
        font-weight: 500;
        color: var(--theme-text-secondary);
      }

      input[type="file"]::file-selector-button {
        background-color: #ffffff;
        color: var(--theme-text-secondary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      input[type="file"]::file-selector-button:hover {
        background-color: var(--theme-bg);
        border-color: var(--theme-accent);
        color: var(--theme-accent);
      }

      select {
        background-color: #ffffff;
        color: var(--theme-text-primary);
        border: 1px solid var(--theme-border);
        padding: 8px 15px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      select:hover {
        border-color: var(--theme-accent);
      }

      select option {
        background-color: #ffffff;
        color: #000000;
      }

      button {
        padding: 12px 24px;
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .btn-process {
        background-color: var(--theme-accent);
      }

      .btn-process:hover {
        background-color: var(--theme-accent-hover);
      }

      .btn-export {
        background-color: var(--theme-success);
      }

      .btn-export:hover {
        background-color: var(--theme-success-hover);
      }

      .btn-export:disabled {
        background-color: #9ca3af;
        cursor: not-allowed;
      }

      #output {
        margin-top: 20px;
      }

      #drawing {
        width: 100%;
        padding: 20px;
        max-height: 65vh;
        overflow: auto;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid var(--theme-border);
      }

      #drawing-svg {
        width: 100%;
        height: 60vh;
        border-radius: 8px;
        background-color: #ffffff;
        border: 1px solid var(--theme-border);
        cursor: grab;
      }

      #drawing-svg:active {
        cursor: grabbing;
      }

      .error {
        color: #ef4444;
        font-weight: bold;
      }

      /* --- SVG 樣式 --- */
      .grid-lines line {
        stroke: #475569;
        stroke-width: 0.5px;
        stroke-dasharray: 4 4;
        vector-effect: non-scaling-stroke;
      }

      .grid-bubble {
        fill: var(--theme-surface);
        stroke: var(--theme-text-secondary);
        /* stroke-width is now controlled by JS */
      }

      .grid-bubble-text {
        fill: var(--theme-text-primary);
        font-weight: 500;
        text-anchor: middle;
        dominant-baseline: middle;
        /* font-size is now controlled by JS */
      }

      .beam-line {
        stroke: #d1d5db;
        stroke-width: 1px;
        vector-effect: non-scaling-stroke; /* 讓所有梁寬度固定 */
      }

      .labeled-beam-line {
        stroke: #3b82f6;
        stroke-width: 1.5px; /* 加粗一點以示區別 */
        vector-effect: non-scaling-stroke;
      }

      .special-beam-line {
        stroke: var(--theme-accent);
        stroke-width: 1.5px; /* 加粗一點以示區別 */
        vector-effect: non-scaling-stroke;
      }

      .beam-label {
        fill: #1e293b;
        font-weight: 500;
        paint-order: stroke;
        stroke: #ffffff;
        stroke-linejoin: round;
        /* font-size and stroke-width are now controlled by JS */
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h1>ETABS 梁自動編號工具</h1>

      <div class="control-area">
        <div class="control-row">
          <div class="control-group">
            <label for="e2kFile">請選擇 ETABS .e2k 檔案:</label>
            <input type="file" id="e2kFile" accept=".e2k" />
          </div>
          <div class="control-group">
            <div class="control-group">
              <input type="checkbox" id="mirrorModeToggle" />
              <label for="mirrorModeToggle">啟用小梁鏡像對稱編號</label>
            </div>
            <button class="btn-process" onclick="processE2k()">開始編號</button>
            <button
              class="btn-export"
              id="exportBtn"
              onclick="exportToExcel()"
              disabled
            >
              匯出成 Excel
            </button>
          </div>
        </div>
        <div class="control-row">
          <div class="control-group">
            <label for="storySelector">顯示樓層:</label>
            <select
              id="storySelector"
              onchange="handleStoryChange()"
              disabled
            ></select>

            <label for="beamTypeSelector">顯示類型:</label>
            <select
              id="beamTypeSelector"
              onchange="handleStoryChange()"
              disabled
            >
              <option value="all">顯示全部</option>
              <option value="main">大梁</option>
              <option value="secondary">小梁</option>
            </select>
          </div>
        </div>
      </div>
      <div id="status"></div>
      <div id="output">
        <div id="drawing">
          <h3>結構平面圖 (<span id="plan-story-name">所有樓層合併</span>)</h3>
          <svg id="drawing-svg"></svg>
        </div>
      </div>
    </div>

    <script>
      // [修改] 擴充AutoCAD模式縮放的初始尺寸常數
      const INITIAL_BEAM_FONT_SIZE = 12;
      const INITIAL_GRID_FONT_SIZE = 10;
      const INITIAL_GRID_BUBBLE_RADIUS = 12;
      const INITIAL_BEAM_LABEL_STROKE = 1.5;
      const INITIAL_GRID_BUBBLE_STROKE = 1;
      // [新增] 定義梁標籤與梁之間的初始距離 (單位：SVG座標)
      const INITIAL_HORIZONTAL_OFFSET = 12;
      const INITIAL_VERTICAL_OFFSET = 8;
      const INITIAL_ANGLED_OFFSET = 6;

      let panZoomInstance = null;
      let fullProcessedBeams = [];
      let fullDrawableBeams = [];
      let availableStories = [];
      let gridData = {};
      let storyOrderInfo = {};
      const TOLERANCE = 0.1;

      async function processE2k() {
        const fileInput = document.getElementById("e2kFile");
        const statusDiv = document.getElementById("status");
        const storySelector = document.getElementById("storySelector");
        const beamTypeSelector = document.getElementById("beamTypeSelector");
        // 【在它後面加上這行】
        const mirrorModeToggle = document.getElementById("mirrorModeToggle");

        statusDiv.innerHTML = "";
        document.getElementById("drawing-svg").innerHTML = "";
        document.getElementById("exportBtn").disabled = true;
        storySelector.innerHTML = "";
        storySelector.disabled = true;
        beamTypeSelector.disabled = true;

        if (panZoomInstance) {
          panZoomInstance.destroy();
          panZoomInstance = null;
        }

        fullProcessedBeams = [];
        fullDrawableBeams = [];
        availableStories = [];
        gridData = {};

        if (fileInput.files.length === 0) {
          statusDiv.innerHTML =
            '<p class="error">Error: Please select an .e2k file first.</p>';
          return;
        }
        const file = fileInput.files[0];
        statusDiv.innerHTML = `<p>Reading file "${file.name}"...</p>`;
        let fileContent;
        try {
          fileContent = await file.text();
        } catch (error) {
          statusDiv.innerHTML = `<p class="error">Failed to read file: ${error.message}</p>`;
          return;
        }

        try {
          const storySectionMatch = fileContent.match(
            /\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i
          );
          if (!storySectionMatch)
            throw new Error(
              "Could not find story definitions ($ STORIES) in the .e2k file."
            );
          const allStoryNames = storySectionMatch[1]
            .trim()
            .split("\n")
            .map((line) => line.match(/STORY\s+"([^"]+)"/i)?.[1])
            .filter(Boolean);
          if (allStoryNames.length === 0)
            throw new Error("Story definition block is empty.");

          availableStories = allStoryNames;
          populateStorySelector();

          statusDiv.innerHTML += `<p>Found ${availableStories.length} stories, parsing components...</p>`;
          gridData = parseGrids(fileContent);
          // --- ↓↓↓ 暫時加入這段除錯碼 ↓↓↓ ---
let debugText = "<h3>偵測到的格線清單：</h3>";
debugText += "<p><b>X軸 (共 " + gridData.x.length + " 條):</b> " + gridData.x.map(g => `'${g.name}'`).join(', ') + "</p>";
debugText += "<p><b>Y軸 (共 " + gridData.y.length + " 條):</b> " + gridData.y.map(g => `'${g.name}'`).join(', ') + "</p>";
statusDiv.innerHTML += debugText;
// --- ↑↑↑ 暫時加入這段除錯碼 ↑↑↑ ---
          const joints = parseJoints(fileContent);

          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(fileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }
          if (allBeamsAcrossStories.length === 0)
            throw new Error("No qualifying beams found on any story.");

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: joints[f.joint1],
            j2: joints[f.joint2],
          }));
          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          const mainBeams = allBeamsAcrossStories.filter((b) => {
            const prop = b.prop.toUpperCase();
            const isNumericBeam = /^\d+(\.\d+)?B/.test(prop);
            return (
              (isNumericBeam ||
                prop.startsWith("B") ||
                prop.startsWith("G") ||
                prop.startsWith("FB") ||
                prop.startsWith("FGB")) &&
              !prop.startsWith("SB") &&
              !prop.startsWith("FSB")
            );
          });
          const secondaryBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("SB") &&
              !b.prop.toUpperCase().startsWith("FSB")
          );
          const secondaryFoundationBeams = allBeamsAcrossStories.filter((b) =>
            b.prop.toUpperCase().startsWith("FSB")
          );
          const specialBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("WB") ||
              b.prop.toUpperCase().startsWith("FWB")
          );

          let allLabeledBeams = [...specialBeams];

          for (const story of availableStories) {
            const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
            const secondaryBeamsInStory = secondaryBeams.filter(
              (b) => b.story === story
            );
            const secondaryFoundationBeamsInStory =
              secondaryFoundationBeams.filter((b) => b.story === story);

            if (mainBeamsInStory.length > 0) {
              const labelComponentMap = generateLabelsForStory(
                mainBeamsInStory,
                joints,
                gridData
              );
              labelComponentMap.forEach((components, beamKey) => {
                const [name, joint1, joint2] = beamKey.split("|");
                const originalBeam = mainBeamsInStory.find(
                  (b) =>
                    b.name === name &&
                    b.joint1 === joint1 &&
                    b.joint2 === joint2
                );
                if (!originalBeam) return;

                const propUpper = originalBeam.prop.toUpperCase();
                const prefix = components.isVertical
                  ? propUpper.startsWith("FB")
                    ? "FB"
                    : "B"
                  : propUpper.startsWith("FB")
                  ? "FG"
                  : "G";

                const finalPrefix = `${prefix}${components.primaryGridName}${components.subGridMarker}`;
                const newLabel = `${finalPrefix}-${components.serial}`;

                allLabeledBeams.push({ ...originalBeam, newLabel });
              });
            }

            if (secondaryBeamsInStory.length > 0) {
              const secondaryBeamLabels = generateSecondaryBeamLabels(
                secondaryBeamsInStory,
                mainBeamsInStory,
                joints,
                "b"
              );
              secondaryBeamLabels.forEach((value, key) => {
                const [name, joint1, joint2] = key.split("|");
                const originalBeam = secondaryBeamsInStory.find(
                  (b) =>
                    b.name === name &&
                    b.joint1 === joint1 &&
                    b.joint2 === joint2
                );
                if (originalBeam) {
                  allLabeledBeams.push({
                    ...originalBeam,
                    newLabel: value.newLabel,
                  });
                }
              });
            }

            if (secondaryFoundationBeamsInStory.length > 0) {
              const foundationBeamLabels = generateSecondaryBeamLabels(
                secondaryFoundationBeamsInStory,
                mainBeamsInStory,
                joints,
                "fb"
              );
              foundationBeamLabels.forEach((value, key) => {
                const [name, joint1, joint2] = key.split("|");
                const originalBeam = secondaryFoundationBeamsInStory.find(
                  (b) =>
                    b.name === name &&
                    b.joint1 === joint1 &&
                    b.joint2 === joint2
                );
                if (originalBeam) {
                  allLabeledBeams.push({
                    ...originalBeam,
                    newLabel: value.newLabel,
                  });
                }
              });
            }
          }

          let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
          finalProcessedData = finalProcessedData.filter(
            (beam) => beam.newLabel
          );

          finalProcessedData.sort((a, b) => {
            const storyCompare =
              storyOrderInfo[a.story] - storyOrderInfo[b.story];
            if (storyCompare !== 0) return storyCompare;

            const aIsSecondary =
              a.newLabel.toLowerCase().startsWith("b") ||
              a.newLabel.toLowerCase().startsWith("fb");
            const bIsSecondary =
              b.newLabel.toLowerCase().startsWith("b") ||
              b.newLabel.toLowerCase().startsWith("fb");

            if (aIsSecondary && !bIsSecondary) return 1;
            if (!aIsSecondary && bIsSecondary) return -1;

            return (a.newLabel || "").localeCompare(b.newLabel || "", "en", {
              numeric: true,
            });
          });

          fullProcessedBeams = finalProcessedData;

          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          statusDiv.innerHTML = `<p>Processing complete! ${fullProcessedBeams.length} items numbered.</p>`;
          if (fullProcessedBeams.length > 0) {
            exportBtn.disabled = false;
          }
        } catch (error) {
          statusDiv.innerHTML = `<p class="error">Processing failed: ${error.message}</p>`;
          console.error(error);
        }
      }

      function populateStorySelector() {
        const selector = document.getElementById("storySelector");
        selector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          selector.appendChild(option);
        });
        selector.disabled = false;
        document.getElementById("beamTypeSelector").disabled = false;
        // 【在最後一行後面加上】
        document.getElementById("mirrorModeToggle").disabled = false;
      }

      function handleStoryChange() {
        const storySelector = document.getElementById("storySelector");
        const beamTypeSelector = document.getElementById("beamTypeSelector");
        const selectedStory = storySelector.value;
        const selectedBeamType = beamTypeSelector.value;
        const svg = document.getElementById("drawing-svg");

        document.getElementById("plan-story-name").textContent =
          selectedStory === "all" ? "All Floors Combined" : selectedStory;

        let beamsToDisplay = fullProcessedBeams;
        let backgroundBeams = fullDrawableBeams;

        if (selectedStory !== "all") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) => b.story === selectedStory
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.story === selectedStory
          );
        }

        if (selectedBeamType === "main") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) =>
              b.newLabel &&
              !(b.newLabel.startsWith("b") || b.newLabel.startsWith("fb"))
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && !/SB/.test(b.prop.toUpperCase())
          );
        } else if (selectedBeamType === "secondary") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) => b.newLabel && b.newLabel && /^(b|fb)\d/.test(b.newLabel)
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && /SB/.test(b.prop.toUpperCase())
          );
        }

        if (panZoomInstance) {
          panZoomInstance.destroy();
          panZoomInstance = null;
        }

        const labeledBeamsWithCoords = beamsToDisplay.map((beam) => {
          const originalBeam = fullDrawableBeams.find(
            (b) =>
              b.name === beam.name &&
              b.story === beam.story &&
              b.joint1 === beam.joint1 &&
              b.joint2 === beam.joint2
          );
          return { ...beam, j1: originalBeam?.j1, j2: originalBeam?.j2 };
        });

        displayResults(labeledBeamsWithCoords, backgroundBeams, svg, gridData);

        if (beamsToDisplay.length > 0 || gridData.x.length > 0) {
          panZoomInstance = svgPanZoom("#drawing-svg", {
            panEnabled: true,
            zoomEnabled: true,
            dblClickZoomEnabled: true,
            controlIconsEnabled: true,
            fit: true,
            center: true,
            minZoom: 0.1,
            maxZoom: 50,
            // [修改] 升級 onZoom 回調以實現完整的 AutoCAD 模式縮放
            onZoom: function (newZoom) {
              // --- 更新梁標籤 ---
              const beamLabels = document.querySelectorAll(
                "#drawing-svg .beam-label"
              );
              beamLabels.forEach((label) => {
                // 1. 反向縮放字體大小和外框
                label.style.fontSize = `${INITIAL_BEAM_FONT_SIZE / newZoom}px`;
                label.style.strokeWidth = `${
                  INITIAL_BEAM_LABEL_STROKE / newZoom
                }px`;

                // 2. 反向縮放位置偏移
                const baseX = parseFloat(label.dataset.baseX);
                const baseY = parseFloat(label.dataset.baseY);
                const orientation = label.dataset.orientation;

                if (orientation === "horizontal") {
                  const newOffsetY = INITIAL_HORIZONTAL_OFFSET / newZoom;
                  label.setAttribute("y", baseY + newOffsetY);
                } else if (orientation === "vertical") {
                  const newOffsetX = INITIAL_VERTICAL_OFFSET / newZoom;
                  const newRotatedX = baseX - newOffsetX;
                  label.setAttribute("x", newRotatedX);
                  // 更新旋轉變換，確保旋轉中心正確
                  label.setAttribute(
                    "transform",
                    `rotate(-90, ${newRotatedX}, ${baseY})`
                  );
                } else if (orientation === "angled") {
                  const newOffsetY = INITIAL_ANGLED_OFFSET / newZoom;
                  label.setAttribute("dy", -newOffsetY);
                }
              });

              // --- 更新網格氣泡 ---
              const gridBubbles = document.querySelectorAll(
                "#drawing-svg .grid-bubble"
              );
              gridBubbles.forEach((bubble) => {
                bubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS / newZoom);
                bubble.style.strokeWidth = `${
                  INITIAL_GRID_BUBBLE_STROKE / newZoom
                }px`;
              });

              const gridBubbleTexts = document.querySelectorAll(
                "#drawing-svg .grid-bubble-text"
              );
              gridBubbleTexts.forEach((text) => {
                text.style.fontSize = `${INITIAL_GRID_FONT_SIZE / newZoom}px`;
              });
            },
          });
        }
      }

      function summarizeFloors(floors, storyOrder) {
        if (!floors || floors.length === 0) return "";
        if (floors.length === 1) return floors[0];

        const sortedFloors = [...floors].sort(
          (a, b) => storyOrder[a] - storyOrder[b]
        );
        const ranges = [];
        let rangeStart = sortedFloors[0];

        for (let i = 1; i < sortedFloors.length; i++) {
          const currentStoryOrder = storyOrder[sortedFloors[i]];
          const prevStoryOrder = storyOrder[sortedFloors[i - 1]];

          if (currentStoryOrder !== prevStoryOrder + 1) {
            if (rangeStart === sortedFloors[i - 1]) {
              ranges.push(rangeStart);
            } else {
              ranges.push(`${rangeStart}~${sortedFloors[i - 1]}`);
            }
            rangeStart = sortedFloors[i];
          }
        }

        if (rangeStart === sortedFloors[sortedFloors.length - 1]) {
          ranges.push(rangeStart);
        } else {
          ranges.push(`${rangeStart}~${sortedFloors[sortedFloors.length - 1]}`);
        }
        return ranges.join(", ");
      }

      function summarizeProperties(floorProps, storyOrder) {
        if (!floorProps || floorProps.length === 0) return "";

        const propsToFloorsMap = new Map();
        for (const { story, prop } of floorProps) {
          if (!propsToFloorsMap.has(prop)) {
            propsToFloorsMap.set(prop, []);
          }
          propsToFloorsMap.get(prop).push(story);
        }

        const summaryParts = [];
        propsToFloorsMap.forEach((floors, prop) => {
          const floorRange = summarizeFloors(floors, storyOrder);
          summaryParts.push(`${floorRange}: ${prop}`);
        });

        summaryParts.sort((a, b) => {
          const firstStoryA = a.split(":")[0].trim().split("~")[0];
          const firstStoryB = b.split(":")[0].trim().split("~")[0];
          return storyOrder[firstStoryA] - storyOrder[firstStoryB];
        });

        return summaryParts.join("; ");
      }

      function displayResults(labeledBeams, allBeams, svg, grids) {
        const beamCoords = allBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        if (beamCoords.length === 0 && (!grids || grids.x.length === 0)) {
          svg.innerHTML =
            '<text x="50%" y="50%" text-anchor="middle" fill="var(--theme-text-secondary)">No data to display</text>';
          return;
        }

        const gridCoordsX = grids.x ? grids.x.map((g) => g.ordinate) : [];
        const gridCoordsY = grids.y ? grids.y.map((g) => g.ordinate) : [];
        const allX = beamCoords.map((p) => p.x).concat(gridCoordsX);
        const allY = beamCoords.map((p) => p.y).concat(gridCoordsY);
        const minX = Math.min(...allX);
        const maxX = Math.max(...allX);
        const minY = Math.min(...allY);
        const maxY = Math.max(...allY);

        const padding = 60;
        const svgWidth = svg.clientWidth;
        const svgHeight = svg.clientHeight;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        let scale =
          Math.min(
            (svgWidth - 2 * padding) / (contentWidth || 1),
            (svgHeight - 2 * padding) / (contentHeight || 1)
          ) * 0.9;
        if (!isFinite(scale) || scale === 0) scale = 1;

        const transformX = (x) => padding + (x - minX) * scale;
        const transformY = (y) => svgHeight - padding - (y - minY) * scale;

        svg.innerHTML = "";

        const allDrawableBeams = allBeams.filter((b) => b.j1 && b.j2);
        allDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));
          line.setAttribute("class", "beam-line");
          svg.appendChild(line);
        });

        if (grids && grids.x && grids.y) {
          const gridGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          gridGroup.setAttribute("class", "grid-lines");
          grids.x.forEach((gridLine) => {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            line.setAttribute("x1", transformX(gridLine.ordinate));
            // [修改] 讓垂直線的起點和終點對齊內容邊界
            line.setAttribute("y1", transformY(maxY));
            line.setAttribute("x2", transformX(gridLine.ordinate));
            // [修改] 讓垂直線的起點和終點對齊內容邊界
            line.setAttribute("y2", transformY(minY));
            gridGroup.appendChild(line);
          });
          grids.y.forEach((gridLine) => {
            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            // [修改] 讓水平線的起點和終點對齊內容邊界
            line.setAttribute("x1", transformX(minX));
            line.setAttribute("y1", transformY(gridLine.ordinate));
            // [修改] 讓水平線的起點和終點對齊內容邊界
            line.setAttribute("x2", transformX(maxX));
            line.setAttribute("y2", transformY(gridLine.ordinate));
            gridGroup.appendChild(line);
          });
          svg.appendChild(gridGroup);

          // ... 之後繪製網格氣泡 (grid bubble) 的程式碼維持不變 ...
          const gridLabelsGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );

          grids.x.forEach((gridLine) => {
            const cx = transformX(gridLine.ordinate);
            const loc = gridLine.bubbleLoc;

            // [修改] 讓氣泡位置基於內容邊界，而非畫布邊界
            const bubbleYTop = transformY(maxY) - padding / 2;
            const bubbleYBottom = transformY(minY) + padding / 2;

            if (loc === "End" || loc === "Both" || !loc) {
              const topBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              topBubble.setAttribute("cx", cx);
              topBubble.setAttribute("cy", bubbleYTop); // 使用新座標
              topBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              topBubble.setAttribute("class", "grid-bubble");
              const topText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              topText.setAttribute("x", cx);
              topText.setAttribute("y", bubbleYTop); // 使用新座標
              topText.setAttribute("class", "grid-bubble-text");
              topText.textContent = gridLine.name;
              gridLabelsGroup.appendChild(topBubble);
              gridLabelsGroup.appendChild(topText);
            }

            if (loc === "Start" || loc === "Both") {
              const bottomBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              bottomBubble.setAttribute("cx", cx);
              bottomBubble.setAttribute("cy", bubbleYBottom); // 使用新座標
              bottomBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              bottomBubble.setAttribute("class", "grid-bubble");
              const bottomText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              bottomText.setAttribute("x", cx);
              bottomText.setAttribute("y", bubbleYBottom); // 使用新座標
              bottomText.setAttribute("class", "grid-bubble-text");
              bottomText.textContent = gridLine.name;
              gridLabelsGroup.appendChild(bottomBubble);
              gridLabelsGroup.appendChild(bottomText);
            }
          });

          grids.y.forEach((gridLine) => {
            const cy = transformY(gridLine.ordinate);
            const loc = gridLine.bubbleLoc;

            // [修改] 讓氣泡位置基於內容邊界，而非畫布邊界
            const bubbleXLeft = transformX(minX) - padding / 2;
            const bubbleXRight = transformX(maxX) + padding / 2;

            if (loc === "Start" || loc === "Both" || !loc) {
              const leftBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              leftBubble.setAttribute("cx", bubbleXLeft); // 使用新座標
              leftBubble.setAttribute("cy", cy);
              leftBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              leftBubble.setAttribute("class", "grid-bubble");
              const leftText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              leftText.setAttribute("x", bubbleXLeft); // 使用新座標
              leftText.setAttribute("y", cy);
              leftText.setAttribute("class", "grid-bubble-text");
              leftText.textContent = gridLine.name;
              gridLabelsGroup.appendChild(leftBubble);
              gridLabelsGroup.appendChild(leftText);
            }

            if (loc === "End" || loc === "Both") {
              const rightBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              rightBubble.setAttribute("cx", bubbleXRight); // 使用新座標
              rightBubble.setAttribute("cy", cy);
              rightBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              rightBubble.setAttribute("class", "grid-bubble");
              const rightText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              rightText.setAttribute("x", bubbleXRight); // 使用新座標
              rightText.setAttribute("y", cy);
              rightText.setAttribute("class", "grid-bubble-text");
              rightText.textContent = gridLine.name;
              gridLabelsGroup.appendChild(rightBubble);
              gridLabelsGroup.appendChild(rightText);
            }
          });
          svg.appendChild(gridLabelsGroup);
        }
        // ... 之後繪製梁 (beam) 和標籤 (label) 的程式碼維持不變 ...
        const labeledDrawableBeams = labeledBeams.filter((b) => b.j1 && b.j2);
        labeledDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          let className = "labeled-beam-line";
          if (
            beam.newLabel.startsWith("b") ||
            beam.newLabel.startsWith("fb") ||
            beam.newLabel === "g1"
          ) {
            className = "special-beam-line";
          } else if (
            beam.prop.toUpperCase().startsWith("WB") ||
            beam.prop.toUpperCase().startsWith("FWB")
          ) {
            className = "special-beam-line";
          }

          line.setAttribute("class", className);
          svg.appendChild(line);

          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );

          const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2;
          const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2;

          text.dataset.baseX = textX;
          text.dataset.baseY = textY;

          const isHorizontal = Math.abs(beam.j1.y - beam.j2.y) < TOLERANCE;
          const isVertical = Math.abs(beam.j1.x - beam.j2.x) < TOLERANCE;

          if (isHorizontal) {
            text.dataset.orientation = "horizontal";
            text.setAttribute("x", textX);
            text.setAttribute("y", textY + INITIAL_HORIZONTAL_OFFSET);
            text.setAttribute("text-anchor", "middle");
          } else if (isVertical) {
            text.dataset.orientation = "vertical";
            const rotatedX = textX - INITIAL_VERTICAL_OFFSET;
            text.setAttribute("x", rotatedX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.setAttribute(
              "transform",
              `rotate(-90, ${rotatedX}, ${textY})`
            );
          } else {
            text.dataset.orientation = "angled";
            const x1_svg = transformX(beam.j1.x);
            const y1_svg = transformY(beam.j1.y);
            const x2_svg = transformX(beam.j2.x);
            const y2_svg = transformY(beam.j2.y);
            let angle =
              (Math.atan2(y2_svg - y1_svg, x2_svg - x1_svg) * 180) / Math.PI;

            if (angle > 90 || angle < -90) {
              angle += 180;
            }

            text.setAttribute("x", textX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "alphabetic");
            text.setAttribute(
              "transform",
              `rotate(${angle}, ${textX}, ${textY})`
            );
            text.setAttribute("dy", -INITIAL_ANGLED_OFFSET);
          }

          text.setAttribute("class", "beam-label");
          text.textContent = beam.newLabel;
          svg.appendChild(text);
        });
      }
      // --- Core Parsing & Labeling Functions (No changes below this line) ---
      function parseGrids(content) {
        const grids = {
          x: [],
          y: [],
        };
        const gridTableSection = content.match(
          /TABLE:\s+"GRID DEFINITIONS - LINES"([\s\S]*?)(?=TABLE:|$)/
        );
        if (gridTableSection) {
          let currentGrid = {};
          const lines = gridTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (trimmedLine === "") {
              if (
                currentGrid.name &&
                currentGrid.type &&
                currentGrid.ordinate !== undefined
              ) {
                if (currentGrid.type.toUpperCase() === "X")
                  grids.x.push(currentGrid);
                else if (currentGrid.type.toUpperCase() === "Y")
                  grids.y.push(currentGrid);
              }
              currentGrid = {};
            } else {
              const match = trimmedLine.match(/(\S+)\s*=\s*"?([^"]*)"?/);
              if (match) {
                const [, key, value] = match;
                if (key === "GridID") currentGrid.name = value;
                if (key === "GridType") currentGrid.type = value;
                if (key === "Ordinate")
                  currentGrid.ordinate = parseFloat(value);
                if (key === "BubbleLoc") currentGrid.bubbleLoc = value;
              }
            }
          });
          if (currentGrid.name) {
            if (currentGrid.type.toUpperCase() === "X")
              grids.x.push(currentGrid);
            else if (currentGrid.type.toUpperCase() === "Y")
              grids.y.push(currentGrid);
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          const gridDollarSection = content.match(/\$ GRIDS([\s\S]*?)(?=\$|$)/);
          if (gridDollarSection) {
            const lines = gridDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              const match = line.match(
                /LABEL\s+"([^"]+)"\s+DIR\s+"(X|Y)"\s+COORD\s+([-\d\.E]+)/i
              );
              if (match) {
                const [, name, type, ordinate] = match;
                const gridInfo = {
                  name,
                  type,
                  ordinate: parseFloat(ordinate),
                };
                if (type.toUpperCase() === "X") grids.x.push(gridInfo);
                else if (type.toUpperCase() === "Y") grids.y.push(gridInfo);
              }
            });
          }
        }
        if (grids.x.length === 0 && grids.y.length === 0) {
          throw new Error("Could not find grid definitions.");
        }
        grids.x = [
          ...new Map(grids.x.map((item) => [item.name, item])).values(),
        ].sort((a, b) => a.ordinate - b.ordinate);
        grids.y = [
          ...new Map(grids.y.map((item) => [item.name, item])).values(),
        ].sort((a, b) => a.ordinate - b.ordinate);
        return grids;
      }

      function parseJoints(content) {
        const joints = {};
        const sciNotationRegex = /"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const pointRegex = /^POINT\s+"([^"]+)"\s+([-\d\.E]+)\s+([-\d\.E]+)/;
        const nameRegex =
          /NAME\s*=\s*(\S+)\s*X\s*=\s*([-\d\.E]+)\s*Y\s*=\s*([-\d\.E]+)/;

        const jointTableSection = content.match(
          /TABLE:\s+"JOINT COORDINATES"([\s\S]*?)(?=TABLE:|$)/
        );
        if (jointTableSection) {
          const lines = jointTableSection[1].trim().split("\n");
          lines.forEach((line) => {
            if (line.trim().startsWith("JOINT")) return;
            const match = line.trim().match(sciNotationRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const lines = content.split("\n");
          lines.forEach((line) => {
            const match = line.trim().match(pointRegex);
            if (match) {
              joints[match[1]] = {
                x: parseFloat(match[2]),
                y: parseFloat(match[3]),
              };
            }
          });
        }
        if (Object.keys(joints).length === 0) {
          const jointDollarSection = content.match(
            /\$ JOINTS([\s\S]*?)(?=\$|$)/s
          );
          if (jointDollarSection) {
            const lines = jointDollarSection[1].trim().split("\n");
            lines.forEach((line) => {
              const match = line.match(nameRegex);
              if (match) {
                joints[match[1]] = {
                  x: parseFloat(match[2]),
                  y: parseFloat(match[3]),
                };
              }
            });
          }
        }
        if (Object.keys(joints).length === 0) {
          throw new Error("Could not find joint coordinate definitions.");
        }
        return joints;
      }

      function parseFrames(content, story) {
        const frames = [];
        const isBeamProp = (propName) => {
          if (!propName) return false;
          const p = propName.toUpperCase();
          const isNumericBeam = /^\d+(\.\d+)?B/.test(p);
          return (
            isNumericBeam ||
            p.startsWith("B") ||
            p.startsWith("G") ||
            p.startsWith("SB") ||
            p.startsWith("WB") ||
            p.startsWith("FB") ||
            p.startsWith("FGB") ||
            p.startsWith("FSB") ||
            p.startsWith("FWB")
          );
        };

        const frameTableSection = content.match(
          /TABLE:\s+"CONNECTIVITY - FRAME"([\s\S]*?)(?=TABLE:|$)/
        );
        const frameAssignSection = content.match(
          /TABLE:\s+"FRAME ASSIGNS - SECTION"([\s\S]*?)(?=TABLE:|$)/
        );
        if (frameTableSection && frameAssignSection) {
          const connectivityLines = frameTableSection[1].trim().split("\n");
          const assignLines = frameAssignSection[1].trim().split("\n");
          const frameProperties = new Map();
          assignLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match && match[2] === story) {
              frameProperties.set(match[1], match[3]);
            }
          });
          connectivityLines.forEach((line) => {
            const match = line
              .trim()
              .match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
            if (match) {
              const [, name, joint1, joint2] = match;
              const propName = frameProperties.get(name);
              if (isBeamProp(propName)) {
                frames.push({
                  name,
                  prop: propName,
                  joint1,
                  joint2,
                  story,
                });
              }
            }
          });
        }
        if (frames.length === 0) {
          const lineConnectivitySection = content.match(
            /\$ LINE CONNECTIVITIES([\s\S]*?)(?=\$|$)/i
          );
          const lineAssignsSection = content.match(
            /\$ LINE ASSIGNS([\s\S]*?)(?=\$|$)/i
          );
          if (lineConnectivitySection && lineAssignsSection) {
            const connectLines = lineConnectivitySection[1].trim().split("\n");
            const assignLines = lineAssignsSection[1].trim().split("\n");
            const beamAssigns = new Map();
            assignLines.forEach((line) => {
              const assignMatch = line.match(
                new RegExp(
                  `LINEASSIGN\\s+"([^"]+)"\\s+"${story}"\\s+SECTION\\s+"([^"]+)"`,
                  "i"
                )
              );
              if (assignMatch) {
                const [, name, propName] = assignMatch;
                if (isBeamProp(propName)) {
                  beamAssigns.set(name, propName);
                }
              }
            });
            connectLines.forEach((line) => {
              const connMatch = line.match(
                /LINE\s+"([^"]+)"\s+BEAM\s+"([^"]+)"\s+"([^"]+)"/i
              );
              if (connMatch) {
                const [, name, joint1, joint2] = connMatch;
                if (beamAssigns.has(name)) {
                  frames.push({
                    name,
                    prop: beamAssigns.get(name),
                    joint1,
                    joint2,
                    story,
                  });
                }
              }
            });
          }
        }
        return frames;
      }

      function findClosestGrid(coordinate, grids) {
        if (!grids || grids.length === 0) return null;
        return grids.reduce((closest, current) => {
          const closestDiff = Math.abs(coordinate - closest.ordinate);
          const currentDiff = Math.abs(coordinate - current.ordinate);
          return currentDiff < closestDiff ? current : closest;
        });
      }

      function generateLabelsForStory(beamsInStory, joints, grids) {
  const labelComponentMap = new Map();

  // --- 開始：這是【最終修正版】的 getBeamSerial 函式 ---
  function getBeamSerial(segment, grids, isHorizontal) {
    const ON_GRID_TOLERANCE = 0.1;

    // 統一的規則：先嘗試將格線名稱轉為數字，如果不行，再用格線的順序(index)
    const getSerialValue = (gridNameToFind, gridArray) => {
      const parsedNum = parseInt(gridNameToFind, 10);
      if (!isNaN(parsedNum) && String(parsedNum) === gridNameToFind) {
        // 如果格線名稱本身就是純數字，直接回傳該數字
        return parsedNum;
      } else {
        // 否則，回傳它在陣列中的 1-based 順序
        const index = gridArray.findIndex((g) => g.name === gridNameToFind);
        return index !== -1 ? index + 1 : NaN;
      }
    };

    if (isHorizontal) {
      const endGrid = findClosestGrid(segment.maxX, grids.x);
      if (Math.abs(segment.maxX - endGrid.ordinate) < ON_GRID_TOLERANCE) {
        // **【水平梁規則1】** 使用終點格線的值
        return getSerialValue(endGrid.name, grids.x);
      }
      const startGrid = findClosestGrid(segment.minX, grids.x);
      // **【水平梁規則2】** 使用起點格線的值
      return getSerialValue(startGrid.name, grids.x);
    } else {
      // 垂直梁的規則比較單純，永遠使用 Y 軸格線的順序
      const endGrid = findClosestGrid(segment.maxY, grids.y);
      if (Math.abs(segment.maxY - endGrid.ordinate) < ON_GRID_TOLERANCE) {
        const index = grids.y.findIndex((g) => g.name === endGrid.name);
        if (index !== -1) {
          return index + 1; // **【垂直梁規則1】** 使用終點格線的 1-based 順序
        }
      }
      const startGrid = findClosestGrid(segment.minY, grids.y);
      const index = grids.y.findIndex((g) => g.name === startGrid.name);
      if (index !== -1) {
        return index + 1; // **【垂直梁規則2】** 使用起點格線的 1-based 順序
      }
    }
    return NaN;
  }
  // --- 結束：getBeamSerial 函式修改完畢 ---

  function parseGridName(gridName) {
    if (!gridName) return "";
    const upperGridName = gridName.toUpperCase();
    if (upperGridName.startsWith("X") || upperGridName.startsWith("Y")) {
      const match = gridName.match(/^[XY](.*)/i);
      return match ? match[1] : gridName;
    }
    return gridName;
  }

  const beamsWithCoords = beamsInStory
    .map((b) => {
      const j1 = joints[b.joint1],
        j2 = joints[b.joint2];
      if (!j1 || !j2) return null;
      return {
        ...b,
        j1,
        j2,
        minX: Math.min(j1.x, j2.x),
        maxX: Math.max(j1.x, j2.x),
        minY: Math.min(j1.y, j2.y),
        maxY: Math.max(j1.y, j2.y),
        centerX: (j1.x + j2.x) / 2,
        centerY: (j1.y + j2.y) / 2,
        isHorizontal: Math.abs(j1.y - j2.y) < TOLERANCE,
        isVertical: Math.abs(j1.x - j2.x) < TOLERANCE,
      };
    })
    .filter(Boolean);

  const processedBeams = new Set();
  beamsWithCoords.forEach((beam) => {
    const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
    if (
      processedBeams.has(beamKey) ||
      (!beam.isHorizontal && !beam.isVertical)
    )
      return;

    processedBeams.add(beamKey);

    let serial;
    let primaryGridName;
    let subGridMarker = "";

    if (beam.isVertical) {
      let onGridLine = grids.x.find(
        (g) => Math.abs(beam.centerX - g.ordinate) < TOLERANCE
      );

      if (onGridLine) {
        primaryGridName = parseGridName(onGridLine.name);
        subGridMarker = "";
      } else {
        const gridBelow = grids.x
          .slice()
          .reverse()
          .find((g) => g.ordinate < beam.centerX);
        const gridAbove = grids.x.find((g) => g.ordinate > beam.centerX);

        if (gridBelow && gridAbove) {
          primaryGridName = parseGridName(gridBelow.name);
          const uniqueXCoords = [
            ...new Set(
              beamsWithCoords
                .filter(
                  (b) =>
                    b.isVertical &&
                    b.centerX > gridBelow.ordinate &&
                    b.centerX < gridAbove.ordinate
                )
                .map((b) => b.centerX.toFixed(2))
            ),
          ].sort((a, b) => parseFloat(a) - parseFloat(b));

          const rank = uniqueXCoords.indexOf(beam.centerX.toFixed(2));
          if (rank !== -1) {
            subGridMarker = String.fromCharCode(97 + rank);
          }
        } else {
          return;
        }
      }
      serial = getBeamSerial(beam, grids, false);
    } else {
      let onGridLine = grids.y.find(
        (g) => Math.abs(beam.centerY - g.ordinate) < TOLERANCE
      );

      if (onGridLine) {
        primaryGridName = parseGridName(onGridLine.name);
        subGridMarker = "";
      } else {
        const gridBelow = grids.y
          .slice()
          .reverse()
          .find((g) => g.ordinate < beam.centerY);
        const gridAbove = grids.y.find((g) => g.ordinate > beam.centerY);

        if (gridBelow && gridAbove) {
          primaryGridName = parseGridName(gridBelow.name);
          const uniqueYCoords = [
            ...new Set(
              beamsWithCoords
                .filter(
                  (b) =>
                    b.isHorizontal &&
                    b.centerY > gridBelow.ordinate &&
                    b.centerY < gridAbove.ordinate
                )
                .map((b) => b.centerY.toFixed(2))
            ),
          ].sort((a, b) => parseFloat(a) - parseFloat(b));

          const rank = uniqueYCoords.indexOf(beam.centerY.toFixed(2));
          if (rank !== -1) {
            subGridMarker = String.fromCharCode(97 + rank);
          }
        } else {
          return;
        }
      }
      serial = getBeamSerial(beam, grids, true);
    }

    if (serial !== undefined && serial !== -1 && !isNaN(serial)) {
      labelComponentMap.set(beamKey, {
        isVertical: beam.isVertical,
        primaryGridName,
        subGridMarker,
        serial,
      });
    }
  });
  return labelComponentMap;
}

      function distance(p1, p2) {
        if (!p1 || !p2) return Infinity;
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      }

      function isPointOnSegment(point, segP1, segP2, tolerance) {
        if (!point || !segP1 || !segP2) return false;
        const segLength = distance(segP1, segP2);
        if (segLength < tolerance) {
          return distance(point, segP1) < tolerance;
        }
        const distSum = distance(point, segP1) + distance(point, segP2);
        return Math.abs(distSum - segLength) < tolerance;
      }
      // =================================================================
// ### 全新鏡像演算法 v4 (最終版，依使用者思路)：開始 ###
// =================================================================

const SYMMETRY_TOLERANCE = 1; // 幾何容許誤差 (10cm)

/**
 * 計算一組梁的精確邊界和形心
 */
function getComponentBounds(component, joints) {
  if (!component || component.length === 0) return null;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  const uniquePoints = new Set();
  component.forEach(beam => {
    const p1 = joints[beam.joint1];
    const p2 = joints[beam.joint2];
    if (p1) uniquePoints.add(p1);
    if (p2) uniquePoints.add(p2);
  });
  if (uniquePoints.size === 0) return null;
  uniquePoints.forEach(p => {
    minX = Math.min(minX, p.x);
    maxX = Math.max(maxX, p.x);
    minY = Math.min(minY, p.y);
    maxY = Math.max(maxY, p.y);
  });
  return { minX, maxX, minY, maxY };
}

/**
 * 鏡像反射一個點
 */
function mirrorPoint(point, axisX) {
    return { x: 2 * axisX - point.x, y: point.y };
}

/**
 * 小梁編號核心函式 (最終版)
 */
// 【最終修正版 - 請複製並完整替換舊的函式】
// 【偵錯版 - 請複製並完整替換舊的函式】
function generateSecondaryBeamLabels(
    secondaryBeamsToNumber,
    mainBeamsInStory,
    joints,
    prefix
) {
    const allLabels = new Map();
    const useMirrorMode = document.getElementById("mirrorModeToggle").checked;

    const coreNumberingEngine = (beamsToNumber, startCounter = 1) => {
        // ... (這段循序編號函式維持不變) ...
        const labels = new Map();
        let counter = startCounter;
        const beamsWithData = beamsToNumber
            .map((b) => {
                const j1_coords = joints[b.joint1], j2_coords = joints[b.joint2];
                if (!j1_coords || !j2_coords) return null;
                const isHorizontal = Math.abs(j1_coords.y - j2_coords.y) < TOLERANCE;
                const isVertical = Math.abs(j1_coords.x - j2_coords.x) < TOLERANCE;
                let startJointName = b.joint1, endJointName = b.joint2;
                if (isHorizontal && j1_coords.x > j2_coords.x) {
                    [startJointName, endJointName] = [b.joint2, b.joint1];
                }
                if (isVertical && j1_coords.y > j2_coords.y) {
                    [startJointName, endJointName] = [b.joint2, b.joint1];
                }
                return { ...b, startJointName, endJointName, isHorizontal, isVertical };
            })
            .filter(Boolean);
        const processed = new Set();
        const beamGroups = [
            beamsWithData.filter((b) => b.isHorizontal).sort((a, b) => joints[a.startJointName].y - joints[b.startJointName].y || joints[a.startJointName].x - joints[b.startJointName].x),
            beamsWithData.filter((b) => b.isVertical).sort((a, b) => joints[a.startJointName].x - joints[b.startJointName].x || joints[a.startJointName].y - joints[b.startJointName].y),
        ];
        let isVerticalRun = false;
        beamGroups.forEach((group) => {
            if (isVerticalRun && counter > 1) {
                const lastNum = counter - 1;
                counter = lastNum % 10 === 0 ? lastNum + 1 : Math.ceil(lastNum / 10) * 10 + 1;
            }
            for (const startBeam of group) {
                const startKey = `${startBeam.name}|${startBeam.joint1}|${startBeam.joint2}`;
                if (processed.has(startKey)) continue;
                let chain = [startBeam];
                processed.add(startKey);
                let currentLink = startBeam;
                while (true) {
                    const nextLink = group.find((b) => {
                        const nextKey = `${b.name}|${b.joint1}|${b.joint2}`;
                        return !processed.has(nextKey) && b.startJointName === currentLink.endJointName;
                    });
                    if (nextLink) {
                        chain.push(nextLink);
                        processed.add(`${nextLink.name}|${nextLink.joint1}|${nextLink.joint2}`);
                        currentLink = nextLink;
                    } else {
                        break;
                    }
                }
                if (chain.length > 1) {
                    chain.forEach((beam, index) => {
                        labels.set(`${beam.name}|${beam.joint1}|${beam.joint2}`, { newLabel: `${prefix}${counter}-${index + 1}` });
                    });
                } else {
                    labels.set(`${chain[0].name}|${chain[0].joint1}|${chain[0].joint2}`, { newLabel: `${prefix}${counter}` });
                }
                counter++;
            }
            isVerticalRun = true;
        });
        return { labels, nextCounter: counter };
    };

    const allBeamsOnStory = [...secondaryBeamsToNumber, ...mainBeamsInStory];
    const componentsRaw = findBuildingComponents(allBeamsOnStory, joints)
        .map(comp => comp.filter(b => secondaryBeamsToNumber.some(sb => sb.name === b.name)))
        .filter(comp => comp.length > 0);

    if (componentsRaw.length === 0) return allLabels;

    const components = componentsRaw
        .map(comp => ({ component: comp, bounds: getComponentBounds(comp, joints) }))
        .sort((a, b) => a.bounds.minX - b.bounds.minX);

    if (!useMirrorMode || components.length < 2) {
        let globalCounter = 1;
        for (const comp of components) {
            const { labels, nextCounter } = coreNumberingEngine(comp.component, globalCounter);
            labels.forEach((value, key) => allLabels.set(key, value));
            globalCounter = nextCounter;
        }
    } else {
        const master = components[0];
        const slave = components[1];
        
        const { labels: masterLabels, nextCounter } = coreNumberingEngine(master.component, 1);
        masterLabels.forEach((value, key) => allLabels.set(key, value));

        const axisX = (master.bounds.maxX + slave.bounds.minX) / 2;
        console.log(`=============================================`);
        console.log(`偵錯開始：鏡像軸 X 座標為 ${axisX}`);
        console.log(`=============================================`);

        // ★★★ 偵錯版鏡像配對邏輯 ★★★
        masterLabels.forEach((labelInfo, masterKey) => {
            const masterBeam = master.component.find(b => `${b.name}|${b.joint1}|${b.joint2}` === masterKey);
            if (!masterBeam) return;
            
            console.log(`\n--- [尋找 ${labelInfo.newLabel} 的鏡像] ---`);
            
            const master_p1 = joints[masterBeam.joint1];
            const master_p2 = joints[masterBeam.joint2];
            const masterMidpoint = { x: (master_p1.x + master_p2.x) / 2, y: (master_p1.y + master_p2.y) / 2 };
            const masterLength = distance(master_p1, master_p2);
            console.log(`主梁 ${masterBeam.name}: 長度=${masterLength.toFixed(3)}, 中點=(${masterMidpoint.x.toFixed(3)}, ${masterMidpoint.y.toFixed(3)})`);

            const mirroredMidpoint = mirrorPoint(masterMidpoint, axisX);
            console.log(`理論鏡像中點: (${mirroredMidpoint.x.toFixed(3)}, ${mirroredMidpoint.y.toFixed(3)})`);

            let foundSlave = null;
            
            slave.component.forEach(b => {
                const slave_p1 = joints[b.joint1];
                const slave_p2 = joints[b.joint2];
                if (!slave_p1 || !slave_p2) return;

                const slaveMidpoint = { x: (slave_p1.x + slave_p2.x) / 2, y: (slave_p1.y + slave_p2.y) / 2 };
                const slaveLength = distance(slave_p1, slave_p2);
                
                const midDist = distance(slaveMidpoint, mirroredMidpoint);
                const lenDiff = Math.abs(slaveLength - masterLength);
                
                // 為了偵錯，我們暫時只印出訊息，不直接 find
                if (midDist < SYMMETRY_TOLERANCE * 2) { // 稍微放寬偵錯範圍
                    console.log(`  -> 正在比對從梁 ${b.name}: 中點距離=${midDist.toFixed(3)}, 長度差異=${lenDiff.toFixed(3)} -> ${ (midDist < SYMMETRY_TOLERANCE && lenDiff < 0.01) ? "✔️ 符合" : "❌ 不符" }`);
                }

                if (midDist < SYMMETRY_TOLERANCE && lenDiff < 1) {
                    foundSlave = b;
                }
            });

            if (foundSlave) {
                console.log(`[成功] ${labelInfo.newLabel} 配對成功！鏡像梁為 ${foundSlave.name}`);
                allLabels.set(`${foundSlave.name}|${foundSlave.joint1}|${foundSlave.joint2}`, { newLabel: labelInfo.newLabel });
            } else {
                console.log(`[失敗] ${labelInfo.newLabel} 在右棟找不到符合條件的鏡像梁！`);
            }
        });
        
        if (components.length > 2) {
            let orphanCounter = nextCounter;
            for (let i = 2; i < components.length; i++) {
                const { labels, nextCounter: updatedCounter } = coreNumberingEngine(components[i].component, orphanCounter);
                labels.forEach((value, key) => allLabels.set(key, value));
                orphanCounter = updatedCounter;
            }
        }
    }

    return allLabels;
}
function findBuildingComponents(allBeamsOnStory, joints) {
  if (!allBeamsOnStory || allBeamsOnStory.length === 0) return [];

  const GEOMETRIC_TOLERANCE = 0.01;
  const components = [];
  const processedBeams = new Set();

  const beamsWithCoords = allBeamsOnStory
    .map((b) => ({
      ...b,
      p1: joints[b.joint1],
      p2: joints[b.joint2],
    }))
    .filter((b) => b.p1 && b.p2);

  function areBeamsConnected(beamA, beamB) {
    if (distance(beamA.p1, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
    if (distance(beamA.p1, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
    if (distance(beamA.p2, beamB.p1) < GEOMETRIC_TOLERANCE) return true;
    if (distance(beamA.p2, beamB.p2) < GEOMETRIC_TOLERANCE) return true;
    if (
      isPointOnSegment(beamA.p1, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
    )
      return true;
    if (
      isPointOnSegment(beamA.p2, beamB.p1, beamB.p2, GEOMETRIC_TOLERANCE)
    )
      return true;
    if (
      isPointOnSegment(beamB.p1, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
    )
      return true;
    if (
      isPointOnSegment(beamB.p2, beamA.p1, beamA.p2, GEOMETRIC_TOLERANCE)
    )
      return true;
    return false;
  }

  for (const startBeam of beamsWithCoords) {
    if (processedBeams.has(startBeam.name)) {
      continue;
    }

    const currentComponent = [];
    const q = [startBeam];
    processedBeams.add(startBeam.name);

    while (q.length > 0) {
      const currentBeam = q.shift();
      currentComponent.push(currentBeam);

      for (const otherBeam of beamsWithCoords) {
        if (processedBeams.has(otherBeam.name)) {
          continue;
        }
        if (areBeamsConnected(currentBeam, otherBeam)) {
          processedBeams.add(otherBeam.name);
          q.push(otherBeam);
        }
      }
    }

    if (currentComponent.length > 0) {
      components.push(currentComponent);
    }
  }
  return components;
}
// =================================================================
// ### 全新鏡像演算法 v4 (最終版，依使用者思路)：結束 ###
// =================================================================

      function applySpecialPrefixRules(allBeams) {
        const processPrefix = (prefix) => {
          const targetBeams = allBeams.filter(
            (b) => b.prop && b.prop.toUpperCase().startsWith(prefix)
          );
          if (targetBeams.length === 0) return null;
          const uniqueProps = [...new Set(targetBeams.map((b) => b.prop))];
          const propRanks = uniqueProps
            .map((prop) => {
              const match = prop.match(/(\d+)[xX](\d+)/);
              if (match) {
                return {
                  propName: prop,
                  area: parseInt(match[1], 10) * parseInt(match[2], 10),
                };
              }
              return {
                propName: prop,
                area: Infinity,
              };
            })
            .sort((a, b) => a.area - b.area);
          const propToLabelMap = new Map();
          propRanks.forEach((propInfo, index) => {
            propToLabelMap.set(propInfo.propName, `${prefix}${index + 1}`);
          });
          return propToLabelMap;
        };
        const wbLabelMap = processPrefix("WB");
        const fwbLabelMap = processPrefix("FWB");
        return allBeams.map((beam) => {
          if (wbLabelMap && wbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: wbLabelMap.get(beam.prop) };
          }
          if (fwbLabelMap && fwbLabelMap.has(beam.prop)) {
            return { ...beam, newLabel: fwbLabelMap.get(beam.prop) };
          }
          return beam;
        });
      }

      function generateFloorFingerprint(story, allBeams, precision = 2) {
        const beamsOnStory = allBeams.filter((b) => b.story === story);
        if (beamsOnStory.length === 0) {
          return "";
        }

        const beamSignatures = beamsOnStory
          .map((beam) => {
            if (!beam.j1 || !beam.j2) return "";

            const x1 = beam.j1.x.toFixed(precision);
            const y1 = beam.j1.y.toFixed(precision);
            const x2 = beam.j2.x.toFixed(precision);
            const y2 = beam.j2.y.toFixed(precision);

            const point1Str = `${x1},${y1}`;
            const point2Str = `${x2},${y2}`;

            return point1Str < point2Str
              ? `${point1Str}|${point2Str}`
              : `${point2Str}|${point1Str}`;
          })
          .filter(Boolean);

        return beamSignatures.sort().join(";");
      }

      function createStandardFloorGroups() {
        if (availableStories.length === 0) return [];

        const sortedStories = [...availableStories].sort(
          (a, b) => storyOrderInfo[a] - storyOrderInfo[b]
        );

        const fingerprints = sortedStories.map((story) => ({
          story,
          fingerprint: generateFloorFingerprint(story, fullDrawableBeams, 2),
        }));

        if (fingerprints.length === 0) return [];

        const groups = [];
        let currentGroup = [fingerprints[0].story];

        for (let i = 1; i < fingerprints.length; i++) {
          if (
            fingerprints[i].fingerprint === fingerprints[i - 1].fingerprint &&
            fingerprints[i].fingerprint !== ""
          ) {
            currentGroup.push(fingerprints[i].story);
          } else {
            groups.push(currentGroup);
            currentGroup = [fingerprints[i].story];
          }
        }
        groups.push(currentGroup);

        return groups;
      }

      function exportToExcel() {
        if (fullProcessedBeams.length === 0) {
          alert("沒有可匯出的資料。");
          return;
        }

        const standardFloorGroups = createStandardFloorGroups();
        const preppedData = [];

        for (const group of standardFloorGroups) {
          const beamsInGroup = fullProcessedBeams.filter((b) =>
            group.includes(b.story)
          );

          if (group.length === 1) {
            beamsInGroup.forEach((beam) => {
              preppedData.push({
                floor: beam.story,
                etabsLabel: beam.name,
                newLabel: beam.newLabel,
              });
            });
          } else {
            const mergedBeamsInGroup = new Map();
            beamsInGroup.forEach((beam) => {
              const key = beam.newLabel;
              if (!mergedBeamsInGroup.has(key)) {
                mergedBeamsInGroup.set(key, {
                  name: beam.name,
                  newLabel: beam.newLabel,
                  floorProps: [],
                });
              }
              mergedBeamsInGroup.get(key).floorProps.push({
                story: beam.story,
                prop: beam.prop,
              });
            });

            mergedBeamsInGroup.forEach((mergedBeam) => {
              const floorString = summarizeFloors(group, storyOrderInfo);
              preppedData.push({
                floor: floorString,
                etabsLabel: mergedBeam.name,
                newLabel: mergedBeam.newLabel,
              });
            });
          }
        }

        const mainBeamsData = [];
        const secondaryBeamsData = [];

        preppedData.forEach((item) => {
          if (
            item.newLabel &&
            (item.newLabel.toLowerCase().startsWith("b") ||
              item.newLabel.toLowerCase().startsWith("fb"))
          ) {
            secondaryBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          } else {
            mainBeamsData.push({
              ETABS編號: item.etabsLabel,
              編號: item.newLabel,
              樓層: item.floor,
            });
          }
        });

        const workbook = XLSX.utils.book_new();

        const mainWs = XLSX.utils.json_to_sheet(mainBeamsData);
        XLSX.utils.book_append_sheet(workbook, mainWs, "大梁");

        const secondaryWs = XLSX.utils.json_to_sheet(secondaryBeamsData);
        XLSX.utils.book_append_sheet(workbook, secondaryWs, "小梁");

        XLSX.writeFile(workbook, "ETABS_梁編號_分頁.xlsx");
      }

      function setupSelectWheelListeners() {
        const selectors = document.querySelectorAll(
          "#storySelector, #beamTypeSelector"
        );

        selectors.forEach((select) => {
          select.addEventListener("wheel", (event) => {
            if (select.options.length === 0 || select.disabled) {
              return;
            }
            event.preventDefault();
            const currentIndex = select.selectedIndex;
            let newIndex = currentIndex;
            if (event.deltaY < 0) {
              newIndex = Math.max(0, currentIndex - 1);
            } else {
              newIndex = Math.min(select.options.length - 1, currentIndex + 1);
            }
            if (newIndex !== currentIndex) {
              select.selectedIndex = newIndex;
              select.dispatchEvent(new Event("change"));
            }
          });
        });
      }

      setupSelectWheelListeners();
    </script>
  </body>
</html>
